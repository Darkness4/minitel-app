import 'dart:convert';

import 'package:minitel_toolbox/data/models/icalendar/event_model.dart';
import 'package:minitel_toolbox/data/models/icalendar/timezone_model.dart';
import 'package:minitel_toolbox/domain/entities/icalendar/parsed_calendar.dart';

/// Parsed calendar generated by [parseCalendar]
class ParsedCalendarModel extends ParsedCalendar {
  const ParsedCalendarModel({
    String version,
    String prodID,
    String calscale,
    TimezoneModel timezone,
    List<EventModel> events,
  }) : super(
          version: version,
          prodID: prodID,
          calscale: calscale,
          timezone: timezone,
          events: events,
        );

  /// Get existing the stream .ics from file
  static Future<ParsedCalendarModel> parse(
      Stream<String> calendarStream) async {
    final TimezoneModelBuffer timezoneBuffer = TimezoneModelBuffer();
    ICalSection mode = ICalSection.None;
    final Map<String, String> vEvent = <String, String>{};
    final List<EventModel> events = <EventModel>[];
    String version;
    String prodID;
    String calscale;

    final Stream<String> lines = calendarStream.transform(const LineSplitter());

    await for (final String data in lines) {
      final List<String> line = data.trim().split(":");
      // Inside a VEVENT
      if (line[0] == 'BEGIN' && line[1] == 'VEVENT') {
        vEvent.clear();
        mode = ICalSection.VEVENT;
        continue; // Skip BEGIN:VEVENT
      }
      if (line[0] == 'END' && line[1] == 'VEVENT') {
        events.add(EventModel.fromMap(vEvent));
        mode = ICalSection.None;
        continue; // Skip END:VEVENT
      }
      if (line[0] == 'BEGIN' && line[1] == 'VTIMEZONE') {
        mode = ICalSection.VTIMEZONE;
        continue; // Skip BEGIN:VTIMEZONE
      }
      if (line[0] == 'END' && line[1] == 'VTIMEZONE') {
        mode = ICalSection.None;
        continue; // Skip END:VTIMEZONE
      }
      if (line[0] == 'BEGIN' && line[1] == 'STANDARD') {
        mode = ICalSection.STANDARD;
        continue; // Skip BEGIN:STANDARD
      }
      if (line[0] == 'END' && line[1] == 'STANDARD') {
        mode = ICalSection.VTIMEZONE;
        continue; // Skip END:STANDARD
      }
      if (line[0] == 'BEGIN' && line[1] == 'DAYLIGHT') {
        mode = ICalSection.DAYLIGHT;
        continue; // Skip BEGIN:DAYLIGHT
      }
      if (line[0] == 'END' && line[1] == 'DAYLIGHT') {
        mode = ICalSection.VTIMEZONE;
        continue; // Skip END:DAYLIGHT
      }

      if (line.length >= 2) {
        switch (mode) {
          case ICalSection.VEVENT:
            vEvent[line[0]] = line[1];
            break;
          case ICalSection.VTIMEZONE:
            if (line[0] == "TZID") {
              timezoneBuffer.tzid = line[1];
            }
            break;
          case ICalSection.STANDARD:
            timezoneBuffer.standard.set(line[0], line[1]);
            break;
          case ICalSection.DAYLIGHT:
            timezoneBuffer.daylight.set(line[0], line[1]);
            break;
          case ICalSection.None:
            switch (line[0]) {
              case "VERSION":
                version = line[1];
                break;
              case "PRODID":
                prodID = line[1];
                break;
              case "CALSCALE":
                calscale = line[1];
                break;
              default:
                print("Invalid key: ${line[0]}");
                if (line[0] != null) {
                  print("with value: ${line[1]}");
                }
            }
        }
      }
    }

    return ParsedCalendarModel(
      calscale: calscale,
      events: events,
      prodID: prodID,
      timezone: timezoneBuffer.toTimezoneModel(),
      version: version,
    );
  }

  @override
  List<Object> get props => [
        this.version,
        this.prodID,
        this.calscale,
        this.timezone,
        this.events,
      ];
}

/// Section of an icalendar
enum ICalSection { None, VEVENT, VTIMEZONE, STANDARD, DAYLIGHT }
