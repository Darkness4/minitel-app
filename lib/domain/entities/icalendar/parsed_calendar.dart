import 'dart:convert';

import 'package:freezed_annotation/freezed_annotation.dart';

import 'event.dart';
import 'timezone.dart';

part 'parsed_calendar.freezed.dart';

/// Section of an icalendar
enum ICalSection { None, VEVENT, VTIMEZONE, STANDARD, DAYLIGHT }

/// Parsed calendar generated by [parseCalendar]
@freezed
abstract class ParsedCalendar with _$ParsedCalendar {
  const factory ParsedCalendar({
    @required @nullable String version,
    @required @nullable String prodID,
    @required @nullable String calscale,
    @required @nullable Timezone timezone,
    @required @nullable List<Event> events,
  }) = _ParsedCalendar;

  /// Get existing the stream .ics from file
  static Future<ParsedCalendar> parse(Stream<String> calendarStream) async {
    ICalSection mode = ICalSection.None;
    final Map<String, String> vEvent = <String, String>{};
    final List<Event> events = <Event>[];
    TimezoneDescription daylight = TimezoneDescription(
      dtstart: DateTime(0),
    );
    TimezoneDescription standard = TimezoneDescription(
      dtstart: DateTime(0),
    );
    Timezone timezone = Timezone(
      daylight: daylight,
      standard: standard,
    );
    String version;
    String prodID;
    String calscale;

    final Stream<String> lines = calendarStream.transform(const LineSplitter());

    await for (final String data in lines) {
      final List<String> line = data.trim().split(":");
      // Inside a VEVENT
      if (line[0] == 'BEGIN' && line[1] == 'VEVENT') {
        vEvent.clear();
        mode = ICalSection.VEVENT;
        continue; // Skip BEGIN:VEVENT
      }
      if (line[0] == 'END' && line[1] == 'VEVENT') {
        events.add(Event.fromMap(vEvent));
        mode = ICalSection.None;
        continue; // Skip END:VEVENT
      }
      if (line[0] == 'BEGIN' && line[1] == 'VTIMEZONE') {
        mode = ICalSection.VTIMEZONE;
        continue; // Skip BEGIN:VTIMEZONE
      }
      if (line[0] == 'END' && line[1] == 'VTIMEZONE') {
        mode = ICalSection.None;
        continue; // Skip END:VTIMEZONE
      }
      if (line[0] == 'BEGIN' && line[1] == 'STANDARD') {
        mode = ICalSection.STANDARD;
        continue; // Skip BEGIN:STANDARD
      }
      if (line[0] == 'END' && line[1] == 'STANDARD') {
        mode = ICalSection.VTIMEZONE;
        continue; // Skip END:STANDARD
      }
      if (line[0] == 'BEGIN' && line[1] == 'DAYLIGHT') {
        mode = ICalSection.DAYLIGHT;
        continue; // Skip BEGIN:DAYLIGHT
      }
      if (line[0] == 'END' && line[1] == 'DAYLIGHT') {
        mode = ICalSection.VTIMEZONE;
        continue; // Skip END:DAYLIGHT
      }

      if (line.length >= 2) {
        switch (mode) {
          case ICalSection.VEVENT:
            vEvent[line[0]] = line[1];
            break;
          case ICalSection.VTIMEZONE:
            if (line[0] == "TZID") {
              timezone = timezone.copyWith(tzid: line[1]);
            }
            break;
          case ICalSection.STANDARD:
            standard = standard.copyWithKeyValue(line[0], line[1]);
            break;
          case ICalSection.DAYLIGHT:
            daylight = daylight.copyWithKeyValue(line[0], line[1]);
            break;
          case ICalSection.None:
            switch (line[0]) {
              case "VERSION":
                version = line[1];
                break;
              case "PRODID":
                prodID = line[1];
                break;
              case "CALSCALE":
                calscale = line[1];
                break;
              default:
                print("Invalid key: ${line[0]}");
                if (line[0] != null) {
                  print("with value: ${line[1]}");
                }
            }
        }
      }
    }

    timezone = timezone.copyWith(
      daylight: daylight,
      standard: standard,
    );

    return ParsedCalendar(
      calscale: calscale,
      events: events,
      prodID: prodID,
      timezone: timezone,
      version: version,
    );
  }
}

extension ParsedCalendarUtils on ParsedCalendar {
  Iterable<Event> get sortedByDTStart sync* {
    this.events.sort((Event event1, Event event2) =>
        event1.dtstart.compareTo(event2.dtstart));

    for (final event in this.events) {
      yield event;
    }
  }
}
